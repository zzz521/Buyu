<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <script>
//        {
//            var a = 1;
//            let b = 2;
//        };
//
//        console.log(a);//1
//        console.log(b);//b is not define
//

//        for(var i=0;i<10;i++){
//
//        };
//        console.log(i);//10
//
//        for(let j=0;j<10;j++){
//
//        }
//        console.log(j);//j is not define
//        //let声明的变量只在它所在的代码块有效
//
//        var a = [];
//        for (var i = 0; i < 10; i++) {
//            a[i] = function () {
//                console.log(i);//被释放
//            };
//        }
//        a[6](); // 10
//        //数组a函数内部的i指向全局i=10
//        var b = [];
//        for (let j = 0; j < 10; j++) {
//            b[j] = function () {
//                console.log(j);
//            };
//        }
//        b[6](); // 6
//          也是由于let的特殊性引起了闭包，其局部变量不被释放
//上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6

//        for (let i = 0; i < 3; i++) {
//            let i = 'abc';
//            console.log(i);
//        } //3次abc
//        for循环循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
//        let a = 10;
//        let a = 12;
//        console.log(a);//a已经被定义
//        var a = 10;
//        var a = 12;
//        console.log(a);
        //var定义的变量后面的a可以覆盖上面的a let不行 在同一个作用域内let不允许重复声明


//        function a(arg) {
//            let arg;
//        };
//        a(2);//报错，在a函数中，参数arg和let arg 在同一个作用域中let不能在函数内部重新声明参数。
//        function b(arg) {
//            {
//                let arg;
//            }
//        }
//        b();//不报错，因为块级作用域不同了
//        var a = 10;
//        let a = 12;
//        console.log(a);//报错

//        var a =10;
//        {
//            let a = 12;
//        }
//        console.log(a);//10



//        let a = 10;
//        var a = 12;
//        console.log(a);//报错

//        console.log(a);
//        var a = 10;
        //var存在变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。
        //等同于:
//        var a;
//        console.log(a);
//        a = 10;

//        console.log(b);
//        let b = 10; //b is not defined

        //关于let的暂时性死区
//        var a = 12;
//        function bb() {
//            let a = 10;
//            console.log(a);//a = 10;
//        };
//        bb();

//            var a = 12;
//            function bb() {
//                console.log(a);//a is not defined;
//                let a = 10;
//            };
//            bb();
            //bb是一个封闭作用域，用let声明的变量进不去，哪怕是同名全局变量。又不存在变量提升，所以报错


//        var tmp = 123;
//        if (true) {
//            tmp = 'abc'; // 报错，tmp is not defined; 此tmp为全局变量
//            let tmp;
//        };//只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
//        var tmp = 123;
//        if (true) {
//            let tmp;
//            tmp = 'abc';
//        }//此时不报错，因为在块级作用域中用let声明了一个tmp，块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
//          ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
//在代码块内，使用let命令声明变量之前，该变量都是不可用的
//        if (true) {
            // TDZ开始
//            tmp = 'abc'; // ReferenceError
//            console.log(tmp); // ReferenceError
//
//            let tmp; // TDZ结束
//            console.log(tmp); // undefined
//
//            tmp = 123;
//            console.log(tmp); // 123
//        }


//        关于typeof
//        console.log(typeof (a));//undefined;
//        var a;//不报错
//        typeof x; // ReferenceError报错，在let声明x之前不可以使用x,所以typeof x一定要先声明在使用
//        let x;


//        var x = x ;//不报错
//        let x = x;//x is not definde 报错，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“
//暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。


//        var a = 10;
//        function bb() {
//            var a = 12;
//            console.log(a);
//        };
//        bb();//局部变量优先
//        var a = 10;
//        function bb() {
//            console.log(a);
//            var a = 12;
//        };
//        bb();//局部优先，变量提升

    </script>
</body>
</html>